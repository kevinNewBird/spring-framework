<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- spring中默认的对象都是单例的,spring会在一级缓存中持有该对象,方便下次直接获取.
	那么如果是原型作用域的话,会创建一个新对象, 此时在一个单例模式的bean下引用一个原型模式的bean,spring是如何处理?

	在此时就需要引用lookup-method标签来解决此问题:通过拦截器的方式,每次需要的时候都去创建最新的对象,而不会把原型对象缓存起来.
	-->
	<bean id="apple" class="com.mashibing.analysis.instanceCreation.methodOverride.lookup.Apple" scope="prototype">
	</bean>
	<bean id="banana" class="com.mashibing.analysis.instanceCreation.methodOverride.lookup.Banana">
	</bean>




	<!--验证单例对象下, 引入多例的对象-->
	<bean id="fruitplate1" class="com.mashibing.analysis.instanceCreation.methodOverride.lookup.FruitPlate">
		<lookup-method name="getFruit" bean="apple"></lookup-method>
	</bean>
	<bean id="fruitplate2" class="com.mashibing.analysis.instanceCreation.methodOverride.lookup.FruitPlate">
		<lookup-method name="getFruit" bean="banana"></lookup-method>
	</bean>



	<!--不使用lookup标签是否可以实现, 单例下引入多例的需求???-->
	<bean id="basket" class="com.mashibing.analysis.instanceCreation.methodOverride.lookup.FruitBasket">
		<property name="apple" ref="apple"/>
 	</bean>

</beans>